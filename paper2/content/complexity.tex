\section{Komplexität}

\subsection{Die Klasse $NC$}
\begin{define}
    Die Klasse $P$ ist die Menge aller Probleme, die sequentiell in 
    polynomieller Zeit $\mathcal{O}(n^k)$ ($k$ konstant) entschieden werden können.
    \begin{equation}
        \begin{split}
            P = \left\{ L \, | \, \text{Es gibt ein Polynom } p\colon \mathbb{N} \to \mathbb{R} \right.
            \text{ und eine} \\ \left. \text{$p(n)$-zeitbeschränkte $DTM$ $A$ mit } L = L(A) \right\}
        \end{split}
    \end{equation}
    $FP$ sei die Menge aller Funktionen, die sequentiell in polynomieller Zeit
    berechnet werden können.
    \cite[S.205]{fgi1}\cite[S.44f]{greenlaw}
\end{define}
%
Probleme werden als effizient parallel entscheidbar bezeichnet, wenn das
hinzunehmen von weiteren Prozessoren eine signifikante Verbesserung der
Laufzeit mit sich bringt.
Diese auch als \emph{highly parallel} bezeichneten Probleme werden in der
Komplexitätsklasse $NC$ (Nick's class, nach Nick Pippenger) zusammengefasst.
%
\begin{define}
    Die Klasse $NC$ ist die Menge aller Probleme, die parallel in
    polylogarithmischer Zeit $t(n) = \mathcal{O}(\log^k n)$ auf polynomiell
    vielen Prozessoren $p(n) = \mathcal{O}(n^c)$ entschieden werden können.
    Analog zu $P$ und $FP$ sei $FNC$ die Menge aller Funktionen, die in
    polylogarithmischer Zeit auf polynomiell vielen Prozessoren berechnet
    werden können.
    \cite[S.44f]{greenlaw}
    % die mit einer Eingabe der Länge $n$ durch einen Algorithmus
    % in $\mathcal{O}\left( \log^k n \right)$ Zeit auf einer PRAM
    % mit $\mathcal{O}\left( n^c \right)$ Prozessoren entschieden werden können.
    % $k$ und $c$ sind von $n$ unabhängige Konstanten.
\end{define}
%
\begin{lemma}
    Ein Problem ist genau dann sequentiell in polynomieller Zeit entscheidbar,
    wenn es parallel in polynomieller Zeit auf polynomiell vielen Prozessoren
    entscheidbar ist.\cite[S.44]{greenlaw}
    \label{seqiffpar}
\end{lemma}
%
Ein sequentieller Algorithmus kann auf einer PRAM mit einem Prozessor in der
gleichen Zeit laufen.
Eine RAM kann eine PRAM simulieren, indem die ursprünglich parallel
ausgeführten Instruktionen, nacheinander ausgeführt werden.
$NC \subseteq P$ gilt also aufgrund von Lemma \ref{seqiffpar}.
%
Liegt ein Problem in $P$, ist also sequentiell in polynomieller Zeit
entscheidbar, und es gibt keine Lösung, die in $NC$ liegt, so wird das
Problem als \emph{inherently sequential} bezeichnet.
Um zu entscheiden, ob $NC \neq P$ gilt, reicht es, für ein Problem aus $P$ zu
zeigen, dass es nicht in $NC$ lösbar ist.
Bisher ist jedoch noch kein Beweis bekannt.
Die Situation ähnelt der Frage, ob $P \neq NP$ gilt.

Um Relationen zwischen Problemen zu beschreiben, wird der Begriff der
Reduktion eingeführt.
Kann man ein Problem $L$ lösen, indem man es in ein anderes Problem $M$ umformt,
für das man einen Algorithmus kennt, so ist $L$ auf $M$ reduzierbar.
%
\begin{define}
    Eine Sprache $L$ heißt many-one-reduzierbar auf eine Sprache $M$
    ($L \leq_m M$), wenn es eine Funktion $f$ gibt, so dass gilt
    \begin{equation}
        x \in L \Leftrightarrow f(x) \in M
    \end{equation}
    $L$ ist $P$-many-one-reduzierbar auf $M$ ($L \leq_m^p M$), wenn $f \in FP$. \\
    $L$ ist $NC$-many-one-reduzierbar auf $M$ ($L \leq_m^{NC} M$), wenn $f \in FNC$.
    \cite[S.47]{greenlaw}
\end{define}
%
Man kann also sagen, wenn $L \leq_m M$ gilt, ist $L$ höchstens so schwer zu
lösen ist wie $M$.
Der durch die Reduktionsfunktion $f$ entstandene Overhead kann je nach Zweck
vernachlässigt werden.
Gelten $f \in FP$ und $M \in P$, so hat der Algorithmus, der $L$ mithilfe von
$M$ löst, eine polynomielle Laufzeit.
Das Entscheiden von $L$ durch Reduktion auf $M$ ist also nicht wesentlich
schwieriger als $M$.
In diesem Fall wurde gezeigt, dass auch $L \in P$ gilt.

\begin{define}
    Ein Problem $L$ in $P$-schwierig bezüglich $NC$, wenn jedes andere Problem
    in $P$ $NC$-many-one-reduzierbar auf $L$ ist. \\
    Ein Problem $L$ ist $P$-vollständig bezüglich $NC$, wenn $L \in P$ und $L$
    $P$-schwierig bezüglich $NC$ ist.
\end{define}
Im folgenden wird vom Bezug auf die Klasse $NC$ ausgegangen, wenn von
$P$-schwierigen oder $P$-vollständigen Problemen gesprochen wird.
%
Nach Definition sind die $P$-vollständigen Probleme, die schwersten in $P$.
Da sich alle diese Probleme aufeinander reduzieren lassen, wäre nur ein highly
parallel Algorithmus für ein einziges Problem dieser Klasse notwendig, um
$NC = P$ zu zeigen.
Bisher ist dies jedoch noch niemandem gelungen.
Man vermutet daher, dass analog zu den $NP$-vollständigen Problemen gilt
\begin{equation}
    \left\{ L \, | \, L \text{ ist $P$-vollständig} \right\} \subseteq P \backslash NC
\end{equation}
Die $P$-vollständigen Probleme sind somit die wahrscheinlichsten Kandidaten
für inherent sequentielle Probleme.
\cite[S.54ff]{greenlaw}\cite[S.535]{jaja}

\subsection{P-vollständige Probleme}

\subsubsection{Bekannte $P$-vollständige Probleme} \hfill \\
In diesem Abschnitt werden Probleme vorgestellt, für die es einen Beweis gibt,
dass sie $P$-vollständig sind.

% TODO: Einleitung
Das übliche Modell für die Berechnung sequentieller Probleme ist die
Turingmaschine.
In der Praxis eingesetzte Systeme ähneln zwar mehr einer RAM, sind jedoch
genauso mächtig.
Die Gemeinsamkeit ist der einzelne Prozessor, der eine Anweisung zur Zeit
verarbeitet bzw. im Fall der Turingmaschine einen Zustandswechsel nach dem
anderen ausführt.
Ist ein Problem inherent sequentiell, so bedeutet es nicht anderes, als dass es
auf einer PRAM oder einem vergleichbaren parallelen Modell nicht wesentlich
schneller lösbar ist als auf einer Turingmaschine.
Eine Turingmaschine zu simulieren ist also ein ideales sequentielles Problem.

% Generic Machine Simulation Problem
\begin{problem}
    Generic Machine Simulation Problem ($GMSP$) \\
    \textbf{Eingabe}:
    \begin{itemize}
        \item einen String $x$
        \item eine kodierte Beschreibung $\overline{M}$ eine Turingmaschine $M$
        \item einen Integer $t$ in Unärdarstellung
    \end{itemize}
    Der Eingabestring ist $x\#\overline{M}\#1^t$ mit $\#$ als Trennzeichen. \\
    %
    \textbf{Problem}: \\
    Akzeptiert $M$ die Eingabe $x$ in $t$ Schritten?
    \cite[S.215]{greenlaw}
\end{problem}
Dass $GMSP$ in $P$ liegt, ist einfach zu sehen:
Die Simulation kann durch eine universelle Turingmaschine $M_{GMSP}$
durchgeführt werden.
Die Turingmaschine wird Schritt für Schritt mit der Eingabe simuliert, bis sie
entweder akzeptiert oder $t$ Schritte simuliert worden sind.
Im ersten Fall wird akzeptiert, im zweiten wird nicht akzeptiert.
$M_{GMSP}$ entscheidet $GMSP$.
Dass $GMSP$ $P$-schwierig ist kann ebenfalls gezeigt werden.
Sei $L$ eine beliebige Sprache für die gelte $L \in P$.
Dann gibt es eine Turingmaschine $M_L$ mit $L = L(M_L)$.
Man berechne eine obere Grenze $p(n) = \mathcal{O}(n^k)$ ($k$ fest) für die
Zeitkomplexität von $M_L$ auf einer Eingabe der Länge $n$.
$M_{GMSP}$ erhält $M_L$, einen String $x$ und ein das Zeitlimit abhängig von der
Länge des Strings als Eingabe: $x\#\overline{M_L}\#1^{p(|x|)}$.
$L$ enthält $x$ genau dann, wenn $M_{GMSP}$ die Eingabe akzeptiert.
Da $GMSP$ in $P$ liegt und $P$-schwierig ist, ist es auch $P$-vollständig.
\cite[S.57ff]{greenlaw}


% circuit value problem
\begin{problem}
    Circuit Value Problem ($CVP$) \\
    \textbf{Eingabe}:
    \begin{itemize}
        \item eine kodierte Beschreibung $\overline{\alpha}$ eines
            boolean Circuit $\alpha$
        \item Eingänge $x_1, \ldots, x_n$
        \item einen Ausgang $y$
    \end{itemize}
    \textbf{Problem}: \\
    Ist der Ausgang $y$ wahr unter der Eingabe $x_1, \ldots, x_n$?
\end{problem}

Das Circuit Value Problem ist ein weiteres zentrales $P$-vollständiges Problem.
Zur Lösung müssen alle Knoten von den Eingaben zu den Ausgaben durchlaufen
werden.
An jedem Knoten wird die jeweilige Operation über den schon vorhandenen Werten
ausgeführt, bis der Ausgang $y$ berechnet ist.
Dies ist ohne weiteres in polynomieller Zeit möglich, $CVP \in P$.
Wenn man zeigen möchte, dass alle Probleme in $P$ auf $CVP$ reduzierbar sind,
kann man wie folgt überlegen:
Für jedes Problem $L \in P$ gibt es einen Algorithmus auf einer Turingmaschine.
Alle verwendeten Digitalrechner sind ebenso mächtig und bestehen aus digitalen
Schaltkreisen.
Diese können wiederum als boolean Circuit angesehen werden.
Es ist möglich eine Turingmaschine durch Circuits zu simulieren, indem der
genaue Zustand in jedem Schritt berechnet wird. \cite[S.59f,71f]{greenlaw}
Für einen kompletten Beweis sei auf Greenlaw, Hoover und Ruzzo \cite[Kapitel 6]{greenlaw}
verwiesen.
Mithilfe von Reduktionen des $CVP$ und verwandter Probleme lassen sich die
$P$-Vollständigkeiten vieler anderer Probleme beweisen.

% Game of Life
\begin{problem}
    Game of Life ($LIFE$) \\
    \textbf{Eingabe}:
    \begin{itemize}
        \item eine Ausgangskonfiguration des Feldes
        \item eine Zeitangabe $t$
        \item eine Zelle $c$ auf dem Spielfeld
    \end{itemize}
    Das Spielfeld ist ein zweidimensionales Gitter und in beiden Dimensionen
    unendlich groß.
    Jede Zelle ist entweder tot oder lebendig und hat acht Nachbarzellen.
    Eine Zelle, die am Zeitpunkt $t$ tot ist, ist bei $t+1$ lebendig,
    wenn sie zur Zeit $t$ genau drei lebende Nachbarzellen hat.
    Eine bei $t$ lebende Zelle bleibt in $t+1$ lebendig, wenn sie bei $t$ zwei
    oder drei lebendige Nachbarzellen hat; andernfalls stirbt sie. \\
    %
    \textbf{Problem}: \\
    Ist die Zelle $c$ nach der Zeit $t$ am Leben?
    \cite[S.211]{greenlaw}
\end{problem}

% Unification
\begin{problem}
    Unifikation ($UNIF$) \\
    \textbf{Eingabe}:
    \begin{itemize}
        \item zwei Terme $s$ und $t$: Jeder Term besteht aus Variablen und
            Funktionssymbolen.
    \end{itemize}
    Eine Substitution für eine Variable $x$ in einem Term $u$ ersetzt alle
    Vorkommen von $x$ in $u$ durch einen weiteren Term $v$. \\
    %
    \textbf{Problem}: \\
    Existiert eine Folge von Substitutionen $\sigma$, die $s$ und $t$
    unifiziert?
    Zwei Terme sind unifizierbar, wenn es ein $\sigma$ gibt, so dass
    $\sigma(s) = \sigma(t)$ gilt.
    \cite[S.171]{greenlaw}
\end{problem}

\subsubsection{Probleme mit unbekannter Komplexität} \hfill \\
Für folgende Probleme gibt es bisher weder einen Algorithmus in $NC$,
noch einen Beweis, dass sie $P$-vollständig sind.

% Integer GCD
\begin{problem}
    Größter gemeinsamer Teiler ($IntegerGCD$) \\
    \textbf{Eingabe}:
    \begin{itemize}
        \item zwei positive $n$-bit Integer $a$ und $b$
    \end{itemize}
    \textbf{Problem}: \\
    Berechne den größten gemeinsamen Teiler von $a$ und $b$ ($\gcd(a,b)$).
    \cite[S.229]{greenlaw}
\end{problem}

% Extened GCD
\begin{problem}
    Erweiterter Euklidischer Algorithmus ($ExtendedGCD$) \\
    \textbf{Eingabe}:
    \begin{itemize}
        \item zwei positive $n$-bit Integer $a$ und $b$
    \end{itemize}
    \textbf{Problem}: \\
    Berechne zwei Integer $s$ und $t$, so dass $as + bt = \gcd(a,b)$ gilt.
    \cite[S.229]{greenlaw}
\end{problem}

% ModPower
\begin{problem}
    Diskrete Exponentialfunktion ($ModPower$) \\
    \textbf{Eingabe}:
    \begin{itemize}
        \item positive $n$-bit Integer $a$, $b$ und $c$
    \end{itemize}
    \textbf{Problem}: \\
    Berechne $a^b \mod c$.
    \cite[S.231]{greenlaw}
\end{problem}
